{
    "benchmarks.MetadataSuite.time_load_partition_info_order6": {
        "code": "class MetadataSuite:\n    def time_load_partition_info_order6(self, cache):\n        PartitionInfo.read_from_dir(cache[1])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTree.from_healpix(pixel_list_a)\n        tree_b = PixelTree.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_info_order6",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:78",
        "type": "time",
        "unit": "seconds",
        "version": "e431b00caf270712fec98bcb3b4b887c36579beca1a9d9cdfbd9571287b975a9",
        "warmup_time": -1
    },
    "benchmarks.MetadataSuite.time_load_partition_info_order7": {
        "code": "class MetadataSuite:\n    def time_load_partition_info_order7(self, cache):\n        PartitionInfo.read_from_dir(cache[0])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTree.from_healpix(pixel_list_a)\n        tree_b = PixelTree.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_info_order7",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:78",
        "type": "time",
        "unit": "seconds",
        "version": "11e7edc14a82f8c063938abf0cca705b6ececf3f9613d27d104ca724895f7c63",
        "warmup_time": -1
    },
    "benchmarks.MetadataSuite.time_load_partition_join_info": {
        "code": "class MetadataSuite:\n    def time_load_partition_join_info(self, cache):\n        PartitionInfo.read_from_dir(cache[2])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTree.from_healpix(pixel_list_a)\n        tree_b = PixelTree.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_join_info",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:78",
        "type": "time",
        "unit": "seconds",
        "version": "c769403a57ec6b1a91c60ffcb9686bf1549195bc2329138d8d69e193dc6a57fd",
        "warmup_time": -1
    },
    "benchmarks.Suite.time_inner_pixel_alignment": {
        "code": "class Suite:\n    def time_inner_pixel_alignment(self):\n        align_trees(self.pixel_tree_1, self.pixel_tree_2)\n\n    def setup(self):\n        self.pixel_list = [HealpixPixel(8, pixel) for pixel in np.arange(100000)]\n        self.pixel_tree_1 = PixelTree.from_healpix(self.pixel_list)\n        self.pixel_tree_2 = PixelTree.from_healpix(\n            [HealpixPixel(9, pixel) for pixel in np.arange(0, 400000, 4)]\n        )",
        "min_run_count": 2,
        "name": "benchmarks.Suite.time_inner_pixel_alignment",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "431c5363f39da36f5e31e36d66778137e224f54fb639625a51f62cb4c21d0a44",
        "warmup_time": -1
    },
    "benchmarks.Suite.time_outer_pixel_alignment": {
        "code": "class Suite:\n    def time_outer_pixel_alignment(self):\n        align_trees(self.pixel_tree_1, self.pixel_tree_2, alignment_type=\"outer\")\n\n    def setup(self):\n        self.pixel_list = [HealpixPixel(8, pixel) for pixel in np.arange(100000)]\n        self.pixel_tree_1 = PixelTree.from_healpix(self.pixel_list)\n        self.pixel_tree_2 = PixelTree.from_healpix(\n            [HealpixPixel(9, pixel) for pixel in np.arange(0, 400000, 4)]\n        )",
        "min_run_count": 2,
        "name": "benchmarks.Suite.time_outer_pixel_alignment",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "dcc2b55115eedf5805bcb52c36ae0f1f9d3b837e7513b05408ecbc0197b37617",
        "warmup_time": -1
    },
    "benchmarks.Suite.time_paths_creation": {
        "code": "class Suite:\n    def time_paths_creation(self):\n        pixel_catalog_files(\"foo/\", self.pixel_list)\n\n    def setup(self):\n        self.pixel_list = [HealpixPixel(8, pixel) for pixel in np.arange(100000)]\n        self.pixel_tree_1 = PixelTree.from_healpix(self.pixel_list)\n        self.pixel_tree_2 = PixelTree.from_healpix(\n            [HealpixPixel(9, pixel) for pixel in np.arange(0, 400000, 4)]\n        )",
        "min_run_count": 2,
        "name": "benchmarks.Suite.time_paths_creation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f02f2a47238716628723a290591daaf89362aeb94beace61f47c818ff2d95f1b",
        "warmup_time": -1
    },
    "benchmarks.Suite.time_pixel_tree_creation": {
        "code": "class Suite:\n    def time_pixel_tree_creation(self):\n        PixelTree.from_healpix(self.pixel_list)\n\n    def setup(self):\n        self.pixel_list = [HealpixPixel(8, pixel) for pixel in np.arange(100000)]\n        self.pixel_tree_1 = PixelTree.from_healpix(self.pixel_list)\n        self.pixel_tree_2 = PixelTree.from_healpix(\n            [HealpixPixel(9, pixel) for pixel in np.arange(0, 400000, 4)]\n        )",
        "min_run_count": 2,
        "name": "benchmarks.Suite.time_pixel_tree_creation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "76c0cb3b7af2250f83e1c2776004130b91d1ce71867e9fcff69c89068bf13bf9",
        "warmup_time": -1
    },
    "benchmarks.time_test_alignment_even_sky": {
        "code": "def time_test_alignment_even_sky():\n    \"\"\"Create alignment from an even distribution at order 7\"\"\"\n    initial_histogram = np.full(hp.order2npix(7), 40)\n    result = hist.generate_alignment(initial_histogram, highest_order=7, threshold=1_000)\n    # everything maps to order 5, given the density\n    for mapping in result:\n        assert mapping[0] == 5",
        "min_run_count": 2,
        "name": "benchmarks.time_test_alignment_even_sky",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c4d4cd79963d85a8084022a7439520a28a2bd2b3f63e581aeb1604b2d4f3d2ac",
        "warmup_time": -1
    },
    "benchmarks.time_test_cone_filter_multiple_order": {
        "code": "def time_test_cone_filter_multiple_order():\n    \"\"\"Create a catalog cone filter where we have multiple orders in the catalog\"\"\"\n    catalog_info = CatalogInfo(\n        **{\n            \"catalog_name\": \"test_name\",\n            \"catalog_type\": \"object\",\n            \"total_rows\": 10,\n            \"epoch\": \"J2000\",\n            \"ra_column\": \"ra\",\n            \"dec_column\": \"dec\",\n        }\n    )\n    pixels = [HealpixPixel(6, 30), HealpixPixel(7, 124), HealpixPixel(7, 5000)]\n    catalog = Catalog(catalog_info, pixels)\n    filtered_catalog = catalog.filter_by_cone(47.1, 6, 30 * 3600)\n    assert filtered_catalog.get_healpix_pixels() == [HealpixPixel(6, 30), HealpixPixel(7, 124)]",
        "min_run_count": 2,
        "name": "benchmarks.time_test_cone_filter_multiple_order",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "80938a43a838f21dafc45157b1f98adffe1cdea3613d42f2b8e7ad6041ad0a52",
        "warmup_time": -1
    },
    "version": 2
}