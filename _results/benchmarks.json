{
    "benchmarks.MetadataSuite.time_load_partition_info_order6": {
        "code": "class MetadataSuite:\n    def time_load_partition_info_order6(self, cache):\n        PartitionInfo.read_from_dir(cache[1])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTreeBuilder.from_healpix(pixel_list_a)\n        tree_b = PixelTreeBuilder.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_info_order6",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:62",
        "type": "time",
        "unit": "seconds",
        "version": "b0aff219fe52d62c8d1712e9bf9fb801ed80d42b6cd7d46e0606affc2916a933",
        "warmup_time": -1
    },
    "benchmarks.MetadataSuite.time_load_partition_info_order7": {
        "code": "class MetadataSuite:\n    def time_load_partition_info_order7(self, cache):\n        PartitionInfo.read_from_dir(cache[0])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTreeBuilder.from_healpix(pixel_list_a)\n        tree_b = PixelTreeBuilder.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_info_order7",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:62",
        "type": "time",
        "unit": "seconds",
        "version": "d7da8deb183080047bf91294a4a0b2b964bd81ec0a732c6940f5613f125eb312",
        "warmup_time": -1
    },
    "benchmarks.MetadataSuite.time_load_partition_join_info": {
        "code": "class MetadataSuite:\n    def time_load_partition_join_info(self, cache):\n        PartitionInfo.read_from_dir(cache[2])\n\n    def setup_cache(self):\n        root_dir = os.getcwd()\n    \n        ## Create partition info for catalog a (only at order 7)\n        pixel_list_a = [HealpixPixel(7, pixel) for pixel in np.arange(100_000)]\n        catalog_path_a = os.path.join(root_dir, \"catalog_a\")\n        os.makedirs(catalog_path_a, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_a)\n        partition_info.write_to_file(os.path.join(catalog_path_a, \"partition_info.csv\"))\n    \n        ## Create partition info for catalog a (only at order 6)\n        pixel_list_b = [HealpixPixel(6, pixel) for pixel in np.arange(25_000)]\n        catalog_path_b = os.path.join(root_dir, \"catalog_b\")\n        os.makedirs(catalog_path_b, exist_ok=True)\n        partition_info = PartitionInfo.from_healpix(pixel_list_b)\n        partition_info.write_to_file(os.path.join(catalog_path_b, \"partition_info.csv\"))\n    \n        ## Fake an association table between the two\n        tree_a = PixelTreeBuilder.from_healpix(pixel_list_a)\n        tree_b = PixelTreeBuilder.from_healpix(pixel_list_b)\n        alignment = align_trees(tree_a, tree_b)\n        alignment_df = alignment.pixel_mapping[\n            [\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME,\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME,\n                PixelAlignment.JOIN_ORDER_COLUMN_NAME,\n                PixelAlignment.JOIN_PIXEL_COLUMN_NAME,\n            ]\n        ]\n        alignment_df = alignment_df.rename(\n            columns={\n                PixelAlignment.PRIMARY_ORDER_COLUMN_NAME: \"Norder\",\n                PixelAlignment.PRIMARY_PIXEL_COLUMN_NAME: \"Npix\",\n            }\n        )\n    \n        association_catalog_path = os.path.join(root_dir, \"assocation_a_b\")\n        os.makedirs(association_catalog_path, exist_ok=True)\n        partition_info = PartitionJoinInfo(alignment_df)\n        partition_info.write_to_csv(association_catalog_path)\n    \n        return (catalog_path_a, catalog_path_b, association_catalog_path)",
        "min_run_count": 2,
        "name": "benchmarks.MetadataSuite.time_load_partition_join_info",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "benchmarks:62",
        "type": "time",
        "unit": "seconds",
        "version": "b1ee35389cc35c47c97e4b59c1a68b11f92f1d4cc9db3bcd32338400177c72e9",
        "warmup_time": -1
    },
    "benchmarks.Suite.time_pixel_tree_creation": {
        "code": "class Suite:\n    def time_pixel_tree_creation(self):\n        PixelTreeBuilder.from_healpix(self.pixel_list)\n\n    def setup(self):\n        self.pixel_list = [HealpixPixel(8, pixel) for pixel in np.arange(100000)]",
        "min_run_count": 2,
        "name": "benchmarks.Suite.time_pixel_tree_creation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "b253603a95d873d4a9a8bdf0fd8e8845cfc04dd474b6a5f8f4ae10540eb19006",
        "warmup_time": -1
    },
    "benchmarks.time_test_alignment_even_sky": {
        "code": "def time_test_alignment_even_sky():\n    \"\"\"Create alignment from an even distribution at order 7\"\"\"\n    initial_histogram = np.full(hp.order2npix(7), 40)\n    result = hist.generate_alignment(initial_histogram, highest_order=7, threshold=1_000)\n    # everything maps to order 5, given the density\n    for mapping in result:\n        assert mapping[0] == 5",
        "min_run_count": 2,
        "name": "benchmarks.time_test_alignment_even_sky",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c4d4cd79963d85a8084022a7439520a28a2bd2b3f63e581aeb1604b2d4f3d2ac",
        "warmup_time": -1
    },
    "benchmarks.time_test_cone_filter_multiple_order": {
        "code": "def time_test_cone_filter_multiple_order():\n    \"\"\"Create a catalog cone filter where we have multiple orders in the catalog\"\"\"\n    catalog_info = CatalogInfo(\n        **{\n            \"catalog_name\": \"test_name\",\n            \"catalog_type\": \"object\",\n            \"total_rows\": 10,\n            \"epoch\": \"J2000\",\n            \"ra_column\": \"ra\",\n            \"dec_column\": \"dec\",\n        }\n    )\n    pixels = [HealpixPixel(6, 30), HealpixPixel(7, 124), HealpixPixel(7, 5000)]\n    catalog = Catalog(catalog_info, pixels)\n    filtered_catalog = catalog.filter_by_cone(47.1, 6, 30)\n    assert filtered_catalog.get_healpix_pixels() == [HealpixPixel(6, 30), HealpixPixel(7, 124)]",
        "min_run_count": 2,
        "name": "benchmarks.time_test_cone_filter_multiple_order",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "1b8e1bb21a1e4ede9063e5c908697ec779d7fdd7aa4d51e70d0010e7e1171f10",
        "warmup_time": -1
    },
    "version": 2
}